dataset_polimi_final_with_holidays_v2 <- read.csv("C:/Users/Ripamonti/Desktop/DM-Project/Modified data/dataset_polimi_final_with_holidays_v2.csv", stringsAsFactors=FALSE)
View(dataset_polimi_final_with_holidays_v2)
predset_complete_with_clusters <- read.csv("C:/Users/Ripamonti/Desktop/DM-Project/Modified data/predset_complete_with_clusters.csv", stringsAsFactors=FALSE)
View(predset_complete_with_clusters)
library(dplyr)
library(xgboost)
library(ggthemes) # visualization
source("src/scoring functions.R")
source("src/sarima.R")
library(stringr)
library(xts)
library(ggplot2)
library(dplyr)
library(tseries)
library(PerformanceAnalytics)
library(forecast)
library(astsa)
library(Metrics)
library(Ckmeans.1d.dp)
library(DiagrammeR)
LogLoss<-function(actual, predicted)
{
predicted<-(pmax(predicted, 0.00001))
predicted<-(pmin(predicted, 0.99999))
result<- -1/length(actual)*(sum((actual*log(predicted)+(1-actual)*log(1-predicted))))
return(result)
}
setClass(Class = "xgboost_pred", representation(predictions = "numeric", prediction_table = "data.frame",
sse = "numeric", mape = "numeric", maxape="numeric"))
setClass(Class = "full_xgboost_pred", representation(predictions = "data.frame", sse_list = "numeric"))
# used to fastly rerun the algorithm
# dataset <- read.csv("~/DM-Project/Modified data/dataset_polimi_with_holidays.csv", stringsAsFactors=FALSE, row.names=NULL)
dataset <- dataset_polimi_final_with_holidays_v2
dataset$stagione[dataset$stagione=="inverno"] <- 1
dataset$stagione[dataset$stagione=="primavera"] <- 2
dataset$stagione[dataset$stagione=="estate"] <- 3
dataset$stagione[dataset$stagione=="autunno"] <- 4
dataset$stagione <- as.numeric(dataset$stagione)
prediction_length <- 0
dataset <- filter(dataset, sottoarea!=20)
# remove sottoarea 78 prodotto 2
temp <- filter(dataset, sottoarea==78, prod==1)
dataset <- filter(dataset, sottoarea!=78)
dataset <- rbind(dataset, temp)
# remove sottoarea 30 prodotto 2
temp <- filter(dataset, sottoarea==32, prod==1)
dataset <- filter(dataset, sottoarea!=32)
dataset <- rbind(dataset, temp)
dataset$data <- as.Date(dataset$data, format = "%Y-%m-%d")
data_train <- filter(dataset, data <= max(data) - prediction_length)
data_test <- filter(dataset, data > max(data) - prediction_length)
data_test <- predset_complete_with_clusters
names(data_test)[names(data_test)=="giorno_sett"] <- "giorno_settimana"
data_test$stagione[data_test$stagione=="inverno"] <- 1
data_test$stagione[data_test$stagione=="primavera"] <- 2
data_test$stagione[data_test$stagione=="estate"] <- 3
data_test$stagione[data_test$stagione=="autunno"] <- 4
data_test$stagione <- as.numeric(data_test$stagione)
data_train$data <- as.Date(data_train$data, format = "%Y-%m-%d")
data_test$data <- as.Date(data_test$data, format = "%Y-%m-%d")
# Convert "vendite" to numeric values if needed
if (class(dataset$vendite) == "factor") {
dataset$vendite <- as.numeric(levels(dataset$vendite))[dataset$vendite]
}
if (class(data_train$vendite) == "factor") {
data_train$vendite <- as.numeric(levels(data_train$vendite))[data_train$vendite]
}
if (class(data_test$vendite) == "factor") {
data_test$vendite <- as.numeric(levels(data_test$vendite))[data_test$vendite]
}
xg_single <- function(n_rounds=45, details=F){
# build datasets
xg_train <- xgb.DMatrix(model.matrix(~ zona + area + sottoarea  + prod + giorno_settimana +
giorno_mese + giorno_anno + settimana_anno + mese + anno + weekend
+ primo_del_mese + cluster3 + cluster6 + cluster20 +
latitudine + longitudine + vacanza + stagione, data=data_train),
label=data_train$vendite, missing=NA)
xg_test <- xgb.DMatrix(model.matrix(~zona + area + sottoarea  + prod + giorno_settimana +
giorno_mese + giorno_anno + settimana_anno + mese + anno + weekend
+ primo_del_mese + cluster3 + cluster6 + cluster20 +
latitudine + longitudine + vacanza + stagione, data=data_test),
label=data_test$vendite, missing=NA)
# removed stagione!
# watchlist <- list( test=xg_test, train=xg_train)
watchlist <- list(train=xg_train)
# build model
xgb_model <- xgb.train(data=xg_train, nrounds = n_rounds, nthread = 4,
watchlist=watchlist, eta = 0.1, eval.metric="logloss", eval.metric="rmse")
xgb_pred <- predict(xgb_model, xg_test)
# get some scoring
# sse <- (1/nrow(data_test))*sum((xgb_pred - data_test$vendite)^2)
# mape <- mean(abs(xgb_pred - data_test$vendite)/mean(data_test$vendite))
# maxape <- max(abs(xgb_pred - data_test$vendite)/mean(data_test$vendite))
# logloss <- LogLoss(data_test$vendite, xgb_pred)
# if (details) {
#   cat("SSE: ", sse, "\n")
#   cat("MAPE: ", mape , "\n")
#   cat("MAX APE: ", maxape, "\n")
#   cat("LOGLOSS: ", logloss, "\n")
# }
# if(details){
#   importance_matrix <- xgb.importance(model = xgb_model)
#   print(importance_matrix)
#   xgb.plot.importance(importance_matrix = importance_matrix)
#
#   xgb.plot.tree(model = xgb_model)
# }
data_test[, "vendite"] <- xgb_pred
# return(new("xgboost_pred", predictions = xgb_pred, prediction_table = data_test, sse = sse, mape = mape, maxape = maxape))
return(data_test)
}
xgboost_pred <- xg_single(n_rounds=900,details=T)
View(xgboost_pred)
bak <- xgboost_pred
xgboost_pred$vendite <- ifelse(xgboost_pred$vendite < 0, 0, xgboost_pred$vendite)
write.csv(bak, "Modified data/predizione_xgboost_eta0.1_round900.csv")
